---
title: "Results--Change over time between early 1900s wells and modern conditions (2010-2020)"
author: "Annette Hilton"
date: "11/15/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Attach Packages

```{r}
# Attach packages 

library(tidyverse)
library(here)
library(janitor)
library(purrr)
library(broom)
library(tibble)
library(dplyr)
library(tidyr)
library(ggpubr)

# Disable scientific notation 

options(scipen=999)
```


## Change over time between early 1900s data and modern (2010-2020) data 

Methods: 

1. Compilation of early well data (see "early_1900s_cleaning.Rmd"--deep wells) and modern USGS data (see "modern_data_cleaning.Rmd")

2. Exported into ArcGIS

3. Buffer of 10 km around deep early 1900s wells, intersect with modern wells 

4. Import into R for data wrangling 

5. Data cleaning & tidying, prepare for statistical tests 

6. Spearman rank correlations 


## Import Data 

### Methods step 4. 

```{r}
# Read in dataset of intersect between early 1900s wells and modern wells within 10 km distance 

intersect <- readr::read_csv(here::here("data", "intersect_modern_deep1900s.txt"))

```

## Data cleaning, tidy, prepare for stats 

### Methods step 5. 

```{r}

intersect_tidy <- intersect %>% 
  clean_names() %>% 
  select(id, latitude, longitude, well_depth, water_leve, artesian, site_no, well_dep_1, median, artesian_1, latitude_1, longitud_1)
  

```

Add criteria: 

1. Each original 1900s well must have at least 3 modern wells associated 

2. Make sure each original well has at least one well that is more shallow and one well that is deeper than it 
 

```{r}
# 1. Criteria of 3 wells per early 1900s well  
# 2. 1900s must have a modern well deeper and shallower than it 

 wells_criteria <- intersect_tidy %>% 
  group_by(id) %>% 
  filter(n() >= 3) %>% 
  mutate(min_depth = min(well_dep_1), 
         max_depth = max(well_dep_1)) %>% 
  filter(well_depth < max_depth & well_depth > min_depth) %>% 
  ungroup()

```

## Statistical tests 

### Methods step 6. 

Spearman rank correlation method calculates the correlation between the ranks of x and the ranks of y variables. 

Variable: Depth of well (well_depth)
Variable: Water level (water_leve)

```{r}
# Use lapply() and split() to split the dataframe by "id" (original early 1900s well) and then iterate the cor.test function for each group (one original 1900s well and modern wells associated) 

spearman<- lapply(
  split(wells_criteria, wells_criteria$id), 
  function(wells_criteria) cor.test(
   wells_criteria$well_dep_1, wells_criteria$median, method = "spearman"))

# Bind results together in a dataframe and indicate the id (rownames_to_column())

results <- as.data.frame(do.call(rbind, spearman)) %>% 
  rownames_to_column(var = "id") %>% 
  select(id, p.value, estimate)

# Remove character string in estimate column (rho)
# Make sure p-value is numeric 

results$estimate <- gsub("[a-z = ()]", "", results$estimate)
results$p.value <- as.numeric(results$p.value)
results$id <- as.numeric(results$id)

# Write as csv 

# write_csv(results_2010_2020, here::here("output_data", "spear_2010_2020.txt"))

```

## Graph 

Graph all townships 2010-2020 

```{r}

# Join results of spearman ranks with full dataset 

full_data <- depth_offset %>% 
  inner_join(results_2010_2020, by = "fishnet")


# Use group_split() to indicate separation by fishnet

plot_2010_2020 <- full_data %>%
  group_split(fishnet)

# Make a function to call each ID as the title of the graph

plots <- function(data){

  plot_name <- data$estimate[1]

ggplot(data, aes(x = well_depth, y = water_leve)) +
  geom_point() +
  labs(x = "Depth (ft)",
       y = "Static Water Level (ft)",
       title = plot_name)
}


all_plots <- purrr::map(plot_2010_2020, plots)

all_plots[[1]]

# Save as PDF

pdf(here::here("output_data", paste0("2010_2020_spear_", Sys.Date(), ".pdf")), height = 11, width = 8.5)
ggarrange(plotlist = all_plots, ncol = 1, nrow = 3, align = "v")
dev.off()
```


